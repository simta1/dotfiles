#!/usr/bin/env bash
set -euo pipefail

# ===== Settings =====
# 디렉토리 제외: 외부 라이브러리/빌드산출물/가상환경/캐시 등
EXCLUDE_DIRS=(
    __pycache__ env .git flask_session migrations libs
    node_modules .venv venv dist build
    .cache .pytest_cache .mypy_cache .ruff_cache
    .idea .vscode .eggs
)

# 파일 이름/패턴 제외: 의존성/잠재적 대용량/미니파이/자주 안 보는 설정 등
EXCLUDE_GLOBS=(
    # 요청 항목들
    "Procfile" "Procfile.dev" "requirements.txt"
    "*.min.css" "*.min.js" "*.min.map"

    # 의존성 메타/락파일
    "package.json" "package-lock.json" "pnpm-lock.yaml" "yarn.lock"
    "pyproject.toml" "poetry.lock" "Pipfile" "Pipfile.lock"

    # 기타 루트 설정/메타(필요 시 제외 유지)
    ".gitattributes" "LICENSE" ".env" "fabfile.py"

    # 대용량/바이너리/미디어/아카이브/폰트/바이트코드
    "*.sqlite" "*.sqlite3" "*.db" "db.sqlite3"
    "*.mp4" "*.mkv" "*.avi" "*.mov"
    "*.png" "*.jpg" "*.jpeg" "*.gif" "*.webp"
    "*.pdf" "*.zip" "*.tar" "*.gz" "*.xz" "*.7z"
    "*.ttf" "*.otf" "*.woff" "*.woff2" "*.eot"
    "*.pyc" "*.pyo"
)

# 제목 색 (굵은 마젠타)
HIGHLIGHT="\033[1;35m"
RESET="\033[0m"

# ===== Build prune expression for directories =====
PRUNE_DIRS=()
for d in "${EXCLUDE_DIRS[@]}"; do
    PRUNE_DIRS+=( -name "$d" -o )
done
if [ ${#PRUNE_DIRS[@]} -gt 0 ]; then
    unset 'PRUNE_DIRS[${#PRUNE_DIRS[@]}-1]'
fi

# ===== Build negative match for excluded file globs =====
# -> -type f ! \( -name 'a' -o -name 'b' ... \)
FILE_NEG=()
for g in "${EXCLUDE_GLOBS[@]}"; do
    FILE_NEG+=( -name "$g" -o )
done
if [ ${#FILE_NEG[@]} -gt 0 ]; then
    unset 'FILE_NEG[${#FILE_NEG[@]}-1]'
    FILE_FILTER=( '!' '(' "${FILE_NEG[@]}" ')' )
else
    FILE_FILTER=()
fi

# ===== Temp file (clipboard; plain text) =====
TMP="$(mktemp)"
> "$TMP"

# ===== Inner block for find -exec =====
run_block='
HIGHLIGHT=$1
RESET=$2
TMP=$3
shift 3

# 내용 기반 텍스트 판별 (확장자 없어도 안전)
is_text() {
    [ ! -s "$1" ] && return 0
    grep -Iq . -- "$1"
}

for file in "$@"; do
    # 텍스트 파일만 출력/복사 (바이너리는 완전 제외)
    if is_text "$file"; then
        # Terminal (colored)
        printf "%b===== %s =====%b\n" "$HIGHLIGHT" "$file" "$RESET"
        cat -- "$file"
        printf "\n\n"   # 항상 파일과 다음 제목 사이에 빈 줄 1줄

        # Clipboard (plain)
        {
            printf "===== %s =====\n" "$file"
            cat -- "$file"
            printf "\n\n"  # 클립보드에서도 동일하게 분리
        } >> "$TMP"
    fi
done
'

# ===== Walk files =====
if [ ${#PRUNE_DIRS[@]} -gt 0 ]; then
    find . -type d \( "${PRUNE_DIRS[@]}" \) -prune -o -type f ${FILE_FILTER+"${FILE_FILTER[@]}"} \
        -exec sh -c "$run_block" _ "$HIGHLIGHT" "$RESET" "$TMP" {} +
else
    find . -type f ${FILE_FILTER+"${FILE_FILTER[@]}"} \
        -exec sh -c "$run_block" _ "$HIGHLIGHT" "$RESET" "$TMP" {} +
fi

# ===== Copy plain text to clipboard (Wayland) =====
if command -v wl-copy >/dev/null 2>&1; then
    wl-copy < "$TMP"
else
    printf "note: wl-copy not found; skipped copying to clipboard.\n" >&2
fi

rm -f "$TMP"
